자주 쓰는 숫자
4294967295 - 2의 32승 - 1

문서화 계획
1. 빠른 소수 찾기 알고리즘 문서 ibi::prime_all
2. 사칙연산 알고리즘
3. 다제곱근 바빌로니아 법
4. 디멘션 플러스
5. 최대공약수 알고리즘과 약분
6. 256진 표기법
7. ibr의 floor 함수와 나머지 연산
8. 테일러 급수를 활용한 다양한 함수 구하기
9. 유리수에서 무리수로의 확장법
10. expr 표현식 함수와 표현식 변수 _(붙이기 연산), xeRepeat(반복연산), xev0(식변수)
11. 귀납과 연역적 추론
12. 사용자 정의 operation (InsideCode)
13. 연산공간 (반복, 역, 성질변화, 순차, 가상정의역, 극한, 미분/적분 ...)

단축기 모음
ctrl + k + 0 : 모두 접기

expr 필요한 기능
1. clean : 식을 정리 (그 값을 구하는 비용이 최대한 저렴한 구성으로 만드는 것.)
2. optimization : 어떤 연산을 할 때, 비용을 적게 만드는 형태로 구성을 변환.
    - 여러 연산이나 함수들의 정리가 필요, 정리로 인해 진행되는 변환을 적용시킬 필요가 있음.
3. const_operation : expr의 값을 연산
4. expr_operation : expr을 연산
5. get_value_approximate : expr의 값을 유리수로 근사하는 것. 

선이 교차하는 지점이 점이 된다.
때문에 선은 점으로 가득차 있다.
하지만 점의 길이는 0이여서 아무리 모여봤자 길이를 가질 수 없다.
실수의 조밀성 (서로 다른 a, b가 있다면 , 반드시 a, b사이의 수가 존재한다.)
를 토대로, 0.9999... = 1 인지 생각하면, 
0.99999... < x < 1 인 어떤 x가 있어야 한다.
양변에서 0.9999... 를 빼면
0 < y < 0.00000... 이 된다. 0과 0.0000... 이 같을 수 밖에 없기 때문에 y는 존재할 수 없다고 말하기도 한다.
하지만, 점이 모여 선이 되는 것처럼 굳이 더하기가 아니더라도, 점과 선과의 관계는 분명 존재한다고 말 할 수 있다.
두 점사이를 점으로 이어서 한 선을 만드는 함수는 반드시 있을 수 있다. 그 관계는 반드시 존재한다고 생각된다.
그러한 연산은 무한히 더하는 것과 같은 것으로, 어쩌면 점의 길이가 0이 아닐수도, 혹은 0을 무한히 더하면 1이 될 수 있을 수 있을 것 같다.
결국 더한다는 것은 가산무한이라는 것이고, 가산무한은 선의 유리수 비율의 점만을 알아낼 수 있겠다. 
때문에 우리가 인식할 수 있는 선 안의 모든 점은 모두 가산적인 무한의 개수다.
하지만 무리수, 비가산 무한이 있는 것 처럼, 점을 비가산무한연산으로 바꾸어 버리면, 선을 채울 수 있다.
결국 0을 가산무한으로 더하면 0이고, 비가산무한연산을 하면 1이 될 수 있다.?
만약 비가산 무한 연산이 있는 것이 맞다면, 0도 하나의 0만이 있는게 아닐 수 있다.
가령 위의 y가 존재할 수 있다. 왜? 0.99999는 가산무한이다. 가산무한으로는 채울 수 없는 것이 있다.
때문에 1에서 0.99999...를 빼면 0과 아주 가깝지만, 0과는 다른 무언가가 나타난다.

수학 관련 표현
https://velog.io/@miyachan/%EC%88%98%ED%95%99-%EA%B3%B5%EC%8B%9D-Markdown%EC%9C%BC%EB%A1%9C-%ED%8E%B8%EC%A7%91%ED%95%98%EA%B8%B0
0123456789
https://www.desmos.com/calculator?lang=ko
desmos 에서 식을 쓰고 copy paste 하면 마크다운 latex형식 나옴.

good music 
Forza Horizon 5 Soundtrack Exclusive: Metrik – Route 174 https://www.youtube.com/watch?v=7zO5LuLWQao
C418 - Excursion https://www.youtube.com/watch?v=jjuMyBEJAH8&list=OLAK5uy_l9bKCTMw16VAlIi2UgvgzlFhgMuItR8p4
minecraft credit : https://www.youtube.com/watch?v=uNCGM7FJ8wQ
Mirror's Edge Soundtrack - Introduction by Solar Fields : https://www.youtube.com/watch?v=aGf5pENphWs   '

연산 속도를 더 빠르게 할 필요가 있음 (최적화)
1. SIMD
2. 아마 fmvecarr 에서 길이가 늘어나면 배열을 복사하는 것 때문에 느려짐. 4096 단위로 inf_array 로 해야 됨.
    -> 일단 fmDynamicArr을 따로 테스트를 해서 완성을 하고 보완해야 겠음.
3. GPU를 활용할 수 있다면 (CUDA or DirectX or OpenCL..)
4. 코드를 asm으로 변환, 디펜던시 체인 탐색
5. 64바이트 코드 얼라인
6. 멀티스레딩 활용
7. 추가적인 최적화 생각해보기

TODO :
<완료 목록>
1. FFTMUL 할때 complex double로 계산. > 완료!
2. fmDynamicArr이 자꾸 지워짐 (뭐 안했는데) 조치 필요. > 완료!
6. 빠른 나누기 (Bitwise, O_N_DIV) > 완료!
4. 빠른 더하기, 빼기 (SIMD) > 완료

3. 할 수 있다면 fmDynamicArr 데이터 크기 정렬하기.
    > 기능 완성했으나 커다란 메모리를 잡는데 오류가 생김.
5. 빠른 곱하기 (FFT, Convolution) 
    > 기능 완성했으나 커다란 메모리를 잡는데 오류가 생김.
8. 빠른 나누기 SIMD 사용해서 더 빠르게 못함?
7. 빠른 ToString > 더 빠르게 할 필요가 있음.
    0.5KB 만 넘어가도 느려지는게 눈에 보임.
    최적화 필요.
    >어떻게?
    1안. 제귀함수를 이용한 최적화.
        100자리면, 10^10을 50번 곱해서 그걸로 나누고 나머지를 구한다.
        나눈값에 대해서 ToString, 나머지에 대해서 ToString 한다.


f\left(x\right)\ =\ -\frac{a}{c}x^{2\ }+\ 2x
f(x) = -(a)/(c)*x^2 + 2x
-> 나누기 뉴턴랩슨법 f를 무한번 합성하면, c/a의 결과가 나옴.

하지만 문제는 우리가 ibi의 정수연산을 할때는, 항상 c가 a보다 큰데, 그러면 
a*x^2 보다 작은 c에 대해서만 연산이 가능하다.
1000000/7을 하면, 2800 이상의 x에서는 작동이 불가하다.
게다가 나누기 연산을 하는데, 그안에 나누기가 들어가 있다..
이건좀..