[0, 0, a2, a3] * [0, 0, b2, b3]

-> [c0, c1, c2, c3] -> a*b의 결과물

0     1    2   3
[a0, a1, a2, a3]
[b0, b1, b2, b3]
->
for(i=0;i<4;++i){FFTresult[i] = FFT(A)[i] * FFT(B)[i]}, 
result = IFFT(FFTresult);

A = [a0, a2, a1, a3]
B = [b0, b2, b1, b3]
FFT(A) =
REAL : [a0+a1+a2+a3, a0-a1, a0+a1-a2-a3, a0-a1]
IMAG : [0, a2-a3, 0, -a2+a3]
FFT(B) =
REAL : [b0+b1+b2+b3, b0-b1, b0+b1-b2-b3, b0-b1]
IMAG : [0, b2-b3, 0, -b2+b3]

//
//(a+bi)(c+di) = (ac-bd) + (ad+bc)i 
//

FFTresult = 
REAL : [(a0+a1+a2+a3)*(b0+b1+b2+b3), ((a0-a1)*(b0-b1) - (a2-a3)*(b2-b3)), 
        (a0+a1-a2-a3)*(b0+b1-b2-b3), ((a0-a1)*(b0-b1) - (a2-a3)*(b2-b3))]
IMAG : [0, (a0-a1)*(b2-b3) + (a2-a3)*(b0-b1), 
        0, (a0-a1)*(-b2+b3) + (-a2+a3)*(b0-b1)]
IFFT(FFTresult) = div(conj(FFT(conj(FFTresult))), 4); // size = 4
conj(FFTresult) = 
REAL : [(a0+a1+a2+a3)*(b0+b1+b2+b3), ((a0-a1)*(b0-b1) - (a2-a3)*(b2-b3)), 
        (a0+a1-a2-a3)*(b0+b1-b2-b3), ((a0-a1)*(b0-b1) - (a2-a3)*(b2-b3))]
IMAG : [0, -(a0-a1)*(b2-b3) - (a2-a3)*(b0-b1), 
        0, -(a0-a1)*(-b2+b3) - (-a2+a3)*(b0-b1)]

FFT(Conj(X)) = 
REAL : [x0+x1+x2+x3, x0-x1, x0+x1-x2-x3, x0-x1]
IMAG : [ix0+ix1+ix2+ix3, x2-x3, 0, -a2+a3]

(a0+ai0*i-a1) + (a2-a3)i


FFT 4
[a0, a1, a2, a3];
SwapData : 1, 2 -> [a0, a2, a1, a3]
OperData : w = 1+ i*(0), tindex : 1, uindex : 0 [a2+a0, a0-a2, a1, a3]
OperData : w = 1+ i*(0), tindex : 3, uindex : 2 [a2+a0, a0-a2, a1+a3, a1-a3]
OperData : w = 1+ i*(0), tindex : 2, uindex : 0 [a2+a0+a1+a3, a0-a2, a2+a0-a1-a3, a1-a3]
OperData : w = 0+ i*(-1), tindex : 3, uindex : 1 [a2+a0+a1+a3, a0-a2-(a1-a3)*i, a2+a0-a1-a3, a0-a2+(a1-a3)*i]

[a0, a1, a2, a3];
[ia0, ia1, ia2, ia3];
REAL : [a2+a0+a1+a3, a0-a2+ia1-ia3, a2+a0-a1-a3, a0-a2-ia1+ia3]
IMAG : [ia2+ia0+ia1+ia3, ia0-ia2-a1+a3, ia2+ia0-ia1-ia3, ia0-ia2+a1-a3]

A = 
[a0, a1, 0, 0]
[0, 0, 0, 0]
FFT(A) = 
REAL : [a0+a1, a0, a0-a1, a0]
IMAG : [0, -a1, 0, a1]
FFT(B) = 
REAL : [b0+b1, b0, b0-b1, b0]
IMAG : [0, -b1, 0, b1]
conj(mul(FFT(A), FFT(B))) = 
REAL : [(a0+a1)*(b0+b1), a0*b0-a1*b1, (a0-a1)*(b0-b1), a0*b0-a1*b1]
IMAG : [0, (a0*b1+a1*b0), 0, -(a0*b1+a1*b0)]

참고 : 
https://www.youtube.com/watch?v=Pct3rS4Y0IA
https://blog.naver.com/yyhjin12/223044578555

import sys
from math import ceil, sqrt
input = sys.stdin.readline
w = 3
mod = 998244353

def power(a, b):
    ret = 1
    while b:
        if b&1: ret = (ret * a) % mod
        a = (a * a) % mod
        b = b >> 1
    return ret

def NTT(A, inv=False):
    n = len(A)    
    
    rev = [0] * n
    for i in range(n): # Sort A
        rev[i] = rev[i >> 1] >> 1
        if i&1:
            rev[i] |= n >> 1
        if i < rev[i]: # Swap condition
            A[i], A[rev[i]] = A[rev[i]], A[i]
    
    x = power(w, (mod - 1) // n)
    if inv: x = power(x, mod - 2)
    
    root = [1]
    for i in range(1, n):
        root.append((root[i-1] * x) % mod)

    i = 2
    while i <= n:
        step = n // i
        for j in range(0, n, i):
            for k in range(i>>1):
                u = A[j|k]
                v = (A[j|k|i >> 1] * root[step*k]) % mod
                A[j|k] = (u + v) % mod
                A[j|k|i >> 1] = (u - v) % mod
                if A[j|k|i >> 1] < 0: A[j|k|i >> 1] += mod
        i <<= 1

    if inv:
        t = power(n, mod - 2)
        for i in range(n):
            A[i] = (A[i] * t) % mod

    return A

isPrime = [1]*(1000001)
for i in range(2, ceil(sqrt(1000000))+1):
    if isPrime[i]:
        j = i*i
        while j < 1000001:
            isPrime[j] = 0
            j += i
isPrime[0], isPrime[1] = 0, 0
for _ in range((1<<21)-len(isPrime)): isPrime.append(0)

X1 = isPrime[:]; X2 = isPrime[:]
goldbach = multiply(X1, X2)

T = int(input())
for _ in range(T):
    N = int(input())

    ans = goldbach[N] // 2
    if isPrime[N//2]: ans += 1
    print(ans)






ibi w = ibi(3);
ibi mod = ibi(998244353);

ibi& NTT_power_mod(ibi& a, ibi& b)
{
    ibi ret = ibi(1);
    while(b != ibi(0)){
        if (b.integer_data[0] & 1) {
            ret = (ret * a) % mod;
        }
        a = (a * a) % mod;
        b = b.bitShiftR(1);
    }
    
    return ret
}

ibi* NTT(ibi* A, unsigned int n, bool inv = false){
    ibi rev //= [0] * n
    for(int i=0;i<n;++i){
        rev.integer_data[i] = rev.integer_data[i >> 1]>>1;
        if(i&1){
            revinteger_data[i] |= n >> 1;
        }
        if(i < rev.integer_data[i]){
            unsigned int temp = A.integer_data[i];
            A[i] = A[rev.integer_data[i]]
            A[rev.integer_data[i]] = temp;
        }
    }
    
    ibi x = NTT_power_mod(w, (mod - ibi(1)) / ibi(n));
    if(inv){
        x = NTT_power_mod(x, mod - ibi(2));
    }
    
    ibi* root = (ibi*)fm->_New(sizeof(ibi)*n, true);
    root[0] = ibi(1);
    for(int i=1;i<=n;++i){
        root[i] = ibi(root[i-1] * x) % mod;
    }

    unsigned int i = 2
    while(i <= n){
        unsigned int step = n / i;
        for(unsigned int j=0;j<n;j+=i){
            for(unsigned int k=0;k<i>>1;++k){
                ibi u = ibi(A[j|k]);
                ibi v = (ibi(A[j|k|i >> 1]) * root[step*k]) % mod;
                A[j|k] = (ibi(u) + ibi(v)) % mod;
                A[j|k|i >> 1] = (ibi(u) - ibi(v)) % mod;
                if(A[j|k|i >> 1] < 0) {
                    A[j|k|i >> 1] += mod;
                }
            }
        }
        i <<= 1
    }

    if(inv){
        ibi t = NTT_power_mod(n, mod - 2)
        for i in range(n):
            A[i] = (A[i] * t) % mod
    }

    return A;
}

ibi& multiply(ibi& a, ibi& b){
    //Check if the length of a and b are both same and power of 2.
    unsigned int n = a.integer_data.size();

    //NTT
    ibi* A = NTT(a, inv=False)
    ibi* B = NTT(b, inv=False)
    ibi* C;

    // A*B(convolusions)
    for(int i=0;i<n;++i){
        C[i] = A[i]*B[i];
    }

    for(int i=0;i<size;++i){
        C[i] = C[i] % mod;
    }

    //INTT
    C = NTT(C, inv=True);

    return C;
}